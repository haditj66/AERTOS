//generated file: C:/AERTOS/AERTOS/src/AE/AECoreTests\include\ThreeDimensionalVector.h
//**********************************************************************
//this is an auto-generated file using the template file located in the directory of C:\CodeGenerator\CodeGenerator\bin\Debug\..\..\FileTemplates\Files
//ONLY WRITE CODE IN THE UserCode_Section BLOCKS
//If you write code anywhere else,  it will be overwritten. modify the actual template file if needing to modify code outside usersection blocks.

//############################################### 
//this is an autogenerated file using cgen's macro2 command. Dont modify this file here unless it is in user sections 
//###############################################

#pragma once


#include "AESPBObservorOutputType.h"
#include "AEUtils.h"
#include "FreeRTOS.h"
#include "AEFilter.h"

#include "AEIntegrationTesting.h"

//UserCode_Sectionheader
//UserCode_Sectionheader_end

template<bool isSubscribable, TEMPLATESPB_Filters>
	class ThreeDimensionalVector :
		public AESPBObservorOutputType <4, 3, isSubscribable,
TEMPLATESPB_FilterParams,
1, false,
1, false,
1, false>
	{
	public:
		ThreeDimensionalVector();
		
		//UserCode_Sectionpublic
//UserCode_Sectionpublic_end


	protected: bool isForVel; 
public: bool  GetisForVel()   const {return isForVel; }
public:  void SetisForVel(bool  _isForVel){isForVel = _isForVel; }


public: void UserInitialize(bool _isForVel )
	{
		isForVel =  _isForVel;

		
		//UserCode_SectionuserInited
//UserCode_SectionuserInited_end
		
		userInitialized = true;
	}
private: bool userInitialized = false;
protected: void CheckIfConfiguredProperly() const override  
	{
		//ThreeDimensionalVector::CheckIfConfiguredProperly();
		if (userInitialized == false)
		{
			// you did not initialize one of your AEobjects
			AEAssertRuntime(userInitialized == true, "user did not call the UserInitailize function for  ThreeDimensionalVector"); 
		} 
		 
	}
	
	private:
	//UserCode_Sectionprivate
//UserCode_Sectionprivate_end

		void RefreshOVERRIDE(float OutputSignal[4]) override;

	};


//UserCode_Sectionfunc
//UserCode_Sectionfunc_end


template<bool isSubscribable, TEMPLATESPB_FiltersFunctionParams>
	inline ThreeDimensionalVector< isSubscribable, TEMPLATESPB_FilterParams>::ThreeDimensionalVector()
	{
		//UserCode_Sectionctor
//UserCode_Sectionctor_end
	}

template<bool isSubscribable, TEMPLATESPB_FiltersFunctionParams>
	inline void ThreeDimensionalVector< isSubscribable, TEMPLATESPB_FilterParams>::RefreshOVERRIDE(float OutputSignal[4])
	{

		float* ch1 = this->InputChannels[0]->ChannelSignalBufferSingle; 
float* ch2 = this->InputChannels[1]->ChannelSignalBufferSingle; 
float* ch3 = this->InputChannels[2]->ChannelSignalBufferSingle; 

 
		//UserCode_Sectionrefresh
		
		float magnitude = sqrtf((ch1[0] * ch1[0]) + (ch2[0] * ch2[0]) + (ch3[0] * ch3[0]));
		float u = magnitude == 0 ? 1 : ch1[0] / magnitude;
		float v = magnitude == 0 ? 0 : ch2[0] / magnitude;
		float w = magnitude == 0 ? 0 : ch3[0] / magnitude;

		OutputSignal[0] = magnitude;
		OutputSignal[1] = u;
		OutputSignal[2] = v;
		OutputSignal[3] = w;
	 
		if (isForVel == true)
		{
			AEITEST_AECoreTests_IgnoreFirstTests("VelocityValue",
				AE_FloatApproximatelyEqual(magnitude, 374.165741, .1)  && 
				AE_FloatApproximatelyEqual(u, 0.267261237, .1),
				"velocity should be 374  ",
				3);		 
		}
		else
		{
			AEITEST_AECoreTests_IgnoreFirstTests("AccelerationValue", magnitude == 0 && u == 1, "acceeration should be zero since velocity is not changing", 3);
		}
//UserCode_Sectionrefresh_end
	}

