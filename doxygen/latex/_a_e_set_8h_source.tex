\hypertarget{_a_e_set_8h_source}{}\doxysection{C\+:/visualgdb\+\_\+projects/\+AERTOSCopy/src/\+AE/\+AESet.h}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{preprocessor}{\#pragma once}}
\DoxyCodeLine{2 }
\DoxyCodeLine{3 \textcolor{preprocessor}{\#include <cstdint>}}
\DoxyCodeLine{4 }
\DoxyCodeLine{5 \textcolor{preprocessor}{\#ifdef RTOS\_USED\_\_FREERTOS}}
\DoxyCodeLine{6 \textcolor{preprocessor}{\#include "{}FreeRTOS.h"{}}}
\DoxyCodeLine{7 \textcolor{preprocessor}{\#include "{}task.h"{}}}
\DoxyCodeLine{8 \textcolor{preprocessor}{\#include "{}timers.h"{}}}
\DoxyCodeLine{9 \textcolor{preprocessor}{\#include "{}queue.h"{}}}
\DoxyCodeLine{10 \textcolor{preprocessor}{\#include "{}semphr.h"{}}}
\DoxyCodeLine{11 \textcolor{preprocessor}{\#include "{}event\_groups.h"{}}}
\DoxyCodeLine{12 }
\DoxyCodeLine{13 \textcolor{preprocessor}{\#endif }}
\DoxyCodeLine{14 }
\DoxyCodeLine{15 }
\DoxyCodeLine{16 }
\DoxyCodeLine{17 \textcolor{keyword}{template}<\textcolor{keyword}{class} TItemType, u\textcolor{keywordtype}{int}32\_t SIZE>}
\DoxyCodeLine{18 \textcolor{keyword}{class }\mbox{\hyperlink{class_a_e_set}{AESet}}}
\DoxyCodeLine{19 \{}
\DoxyCodeLine{20 \textcolor{keyword}{public}:}
\DoxyCodeLine{21 }
\DoxyCodeLine{22     \textcolor{comment}{//typedef bool(*AESetCompareFunc)(TItemType itemToCompare1, TItemType itemToCompare2);}}
\DoxyCodeLine{23     \textcolor{keyword}{typedef} void(*ForEachFunc\_t)(\textcolor{keywordtype}{void}* thisptr, TItemType itemInSet);}
\DoxyCodeLine{24     \textcolor{keyword}{typedef} bool(*ForEachFuncTrue\_t)(TItemType itemToPass, TItemType itemInSet);}
\DoxyCodeLine{25      }
\DoxyCodeLine{27     \mbox{\hyperlink{class_a_e_set_a599f98d306e80a2c3a5d541125bf1b45}{AESet}}(TItemType defaultNullValue) \{}
\DoxyCodeLine{28         mutexForInsertRemove = xSemaphoreCreateMutex();}
\DoxyCodeLine{29 }
\DoxyCodeLine{30         DefaultNullValue = defaultNullValue;}
\DoxyCodeLine{31         size = 0;}
\DoxyCodeLine{32         \textcolor{keywordflow}{for} (uint32\_t i = 0; i < SIZE; i++)}
\DoxyCodeLine{33         \{}
\DoxyCodeLine{34             buffer[i] = DefaultNullValue;}
\DoxyCodeLine{35         \}}
\DoxyCodeLine{36     \};}
\DoxyCodeLine{37 }
\DoxyCodeLine{38     \textcolor{keywordtype}{void} Insert(TItemType itemToInsert);}
\DoxyCodeLine{39     \textcolor{keywordtype}{void} Remove(TItemType itemToRemove);}
\DoxyCodeLine{40     \textcolor{keywordtype}{void} RemoveAll();}
\DoxyCodeLine{41     \textcolor{keywordtype}{void} ForEach(\textcolor{keywordtype}{void}* thisptr, ForEachFunc\_t forEachFunc) \textcolor{keyword}{const};}
\DoxyCodeLine{42     \textcolor{keywordtype}{bool} ForEachIsAnyTrueWithItem(TItemType itemToPass, ForEachFuncTrue\_t forEachFunc) \textcolor{keyword}{const};}
\DoxyCodeLine{43     }
\DoxyCodeLine{44     uint32\_t Size() \textcolor{keyword}{const};}
\DoxyCodeLine{45 }
\DoxyCodeLine{46 \textcolor{keyword}{private}:}
\DoxyCodeLine{47 }
\DoxyCodeLine{48     xSemaphoreHandle mutexForInsertRemove;}
\DoxyCodeLine{49 }
\DoxyCodeLine{50     uint32\_t size;}
\DoxyCodeLine{51     \textcolor{comment}{//AESetCompareFunc AESetComparefunc;}}
\DoxyCodeLine{52     TItemType buffer[SIZE];}
\DoxyCodeLine{53     TItemType DefaultNullValue;}
\DoxyCodeLine{54 }
\DoxyCodeLine{55 }
\DoxyCodeLine{56 \};}
\DoxyCodeLine{57 }
\DoxyCodeLine{58 \textcolor{keyword}{template}<\textcolor{keyword}{class} TItemType, u\textcolor{keywordtype}{int}32\_t SIZE>}
\DoxyCodeLine{59 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} \mbox{\hyperlink{class_a_e_set}{AESet<TItemType, SIZE>::Remove}}(TItemType itemToInsert)}
\DoxyCodeLine{60 \{}
\DoxyCodeLine{61     xSemaphoreTake(this-\/>mutexForInsertRemove, portMAX\_DELAY);}
\DoxyCodeLine{62 }
\DoxyCodeLine{63     \textcolor{keywordtype}{bool} foundItemToRemove = \textcolor{keyword}{false};}
\DoxyCodeLine{64     \textcolor{keywordflow}{for} (uint32\_t i = 0; i < SIZE; i++)}
\DoxyCodeLine{65     \{}
\DoxyCodeLine{66         \textcolor{keywordflow}{if} (this-\/>buffer[i] == itemToInsert)}
\DoxyCodeLine{67         \{}
\DoxyCodeLine{68             foundItemToRemove = \textcolor{keyword}{true};}
\DoxyCodeLine{69             this-\/>buffer[i] = this-\/>DefaultNullValue;}
\DoxyCodeLine{70             \textcolor{keywordflow}{break};}
\DoxyCodeLine{71         \}}
\DoxyCodeLine{72     \}}
\DoxyCodeLine{73     \textcolor{comment}{//assert that the item you tried to remove was in fact in the set.}}
\DoxyCodeLine{74     \textcolor{comment}{//configASSERT(foundItemToRemove);}}
\DoxyCodeLine{75     \textcolor{keywordflow}{if} (foundItemToRemove == \textcolor{keyword}{true})}
\DoxyCodeLine{76     \{}
\DoxyCodeLine{77         this-\/>size-\/-\/;}
\DoxyCodeLine{78     \}}
\DoxyCodeLine{79 }
\DoxyCodeLine{80     xSemaphoreGive(this-\/>mutexForInsertRemove);}
\DoxyCodeLine{81     }
\DoxyCodeLine{82 \}}
\DoxyCodeLine{83 }
\DoxyCodeLine{84 \textcolor{keyword}{template}<\textcolor{keyword}{class} TItemType, u\textcolor{keywordtype}{int}32\_t SIZE>}
\DoxyCodeLine{85 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} \mbox{\hyperlink{class_a_e_set}{AESet<TItemType, SIZE>::RemoveAll}}()}
\DoxyCodeLine{86 \{}
\DoxyCodeLine{87     xSemaphoreTake(this-\/>mutexForInsertRemove, portMAX\_DELAY);}
\DoxyCodeLine{88 }
\DoxyCodeLine{89     \textcolor{keywordflow}{for} (uint32\_t i = 0; i < SIZE; i++)}
\DoxyCodeLine{90     \{}
\DoxyCodeLine{91         this-\/>buffer[i] = this-\/>DefaultNullValue;}
\DoxyCodeLine{92     \}}
\DoxyCodeLine{93 }
\DoxyCodeLine{94     this-\/>size = 0;}
\DoxyCodeLine{95 }
\DoxyCodeLine{96     xSemaphoreGive(this-\/>mutexForInsertRemove);}
\DoxyCodeLine{97 \}}
\DoxyCodeLine{98 }
\DoxyCodeLine{99 \textcolor{keyword}{template}<\textcolor{keyword}{class} TItemType, u\textcolor{keywordtype}{int}32\_t SIZE>}
\DoxyCodeLine{100 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} \mbox{\hyperlink{class_a_e_set}{AESet<TItemType, SIZE>::ForEach}}(\textcolor{keywordtype}{void}* thisptr,ForEachFunc\_t forEachFunc)\textcolor{keyword}{ const}}
\DoxyCodeLine{101 \textcolor{keyword}{}\{}
\DoxyCodeLine{102     \textcolor{keywordflow}{if} (this-\/>size > 0)}
\DoxyCodeLine{103     \{}
\DoxyCodeLine{104         \textcolor{keywordflow}{for} (uint16\_t i = 0; i < SIZE; i++)}
\DoxyCodeLine{105         \{}
\DoxyCodeLine{106             \textcolor{keywordflow}{if} (this-\/>buffer[i] != this-\/>DefaultNullValue)}
\DoxyCodeLine{107             \{}
\DoxyCodeLine{108                 forEachFunc(thisptr, this-\/>buffer[i]);}
\DoxyCodeLine{109             \}}
\DoxyCodeLine{110         \}}
\DoxyCodeLine{111     \} }
\DoxyCodeLine{112 }
\DoxyCodeLine{113 \}}
\DoxyCodeLine{114 }
\DoxyCodeLine{115 \textcolor{keyword}{template}<\textcolor{keyword}{class} TItemType, u\textcolor{keywordtype}{int}32\_t SIZE>}
\DoxyCodeLine{116 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} \mbox{\hyperlink{class_a_e_set}{AESet<TItemType, SIZE>::ForEachIsAnyTrueWithItem}}(TItemType itemToPass, ForEachFuncTrue\_t forEachFuncTrue)\textcolor{keyword}{ const}}
\DoxyCodeLine{117 \textcolor{keyword}{}\{}
\DoxyCodeLine{118 }
\DoxyCodeLine{119     \textcolor{keywordflow}{if} (this-\/>size > 0)}
\DoxyCodeLine{120     \{}
\DoxyCodeLine{121         \textcolor{keywordflow}{for} (uint16\_t i = 0; i < SIZE; i++)}
\DoxyCodeLine{122         \{}
\DoxyCodeLine{123             \textcolor{keywordflow}{if} (this-\/>buffer[i] != this-\/>DefaultNullValue)}
\DoxyCodeLine{124             \{}
\DoxyCodeLine{125                 \textcolor{keywordtype}{bool} istrue = forEachFuncTrue(itemToPass, this-\/>buffer[i]);}
\DoxyCodeLine{126                 \textcolor{keywordflow}{if} (istrue == \textcolor{keyword}{true})}
\DoxyCodeLine{127                 \{}
\DoxyCodeLine{128                     \textcolor{keywordflow}{return} istrue;}
\DoxyCodeLine{129                 \}}
\DoxyCodeLine{130             \}}
\DoxyCodeLine{131         \}}
\DoxyCodeLine{132     \}}
\DoxyCodeLine{133 }
\DoxyCodeLine{134     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{135 }
\DoxyCodeLine{136 \}}
\DoxyCodeLine{137 }
\DoxyCodeLine{138 \textcolor{keyword}{template}<\textcolor{keyword}{class} TItemType, u\textcolor{keywordtype}{int}32\_t SIZE>}
\DoxyCodeLine{139 \textcolor{keyword}{inline} uint32\_t \mbox{\hyperlink{class_a_e_set}{AESet<TItemType, SIZE>::Size}}()\textcolor{keyword}{ const}}
\DoxyCodeLine{140 \textcolor{keyword}{}\{}
\DoxyCodeLine{141     \textcolor{keywordflow}{return} this-\/>size;}
\DoxyCodeLine{142 \}}
\DoxyCodeLine{143  }
\DoxyCodeLine{144 }
\DoxyCodeLine{145 \textcolor{keyword}{template}<\textcolor{keyword}{class} TItemType, u\textcolor{keywordtype}{int}32\_t SIZE>}
\DoxyCodeLine{146 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} \mbox{\hyperlink{class_a_e_set}{AESet<TItemType, SIZE>::Insert}}(TItemType itemToInsert)}
\DoxyCodeLine{147 \{}
\DoxyCodeLine{148     xSemaphoreTake(mutexForInsertRemove, portMAX\_DELAY);}
\DoxyCodeLine{149   }
\DoxyCodeLine{150     \textcolor{keywordtype}{bool} BufferWasFull = \textcolor{keyword}{true};}
\DoxyCodeLine{151     \textcolor{keywordflow}{for} (uint32\_t i = 0; i < SIZE; i++)}
\DoxyCodeLine{152     \{}
\DoxyCodeLine{153         \textcolor{keywordflow}{if} (this-\/>buffer[i] == this-\/>DefaultNullValue)}
\DoxyCodeLine{154         \{}
\DoxyCodeLine{155             BufferWasFull = \textcolor{keyword}{false};}
\DoxyCodeLine{156             this-\/>buffer[i] = itemToInsert;}
\DoxyCodeLine{157             \textcolor{keywordflow}{break};}
\DoxyCodeLine{158         \}}
\DoxyCodeLine{159     \}}
\DoxyCodeLine{160 }
\DoxyCodeLine{161     \textcolor{comment}{//assert that Buffer is not full}}
\DoxyCodeLine{162     configASSERT(!BufferWasFull);}
\DoxyCodeLine{163 }
\DoxyCodeLine{164     this-\/>size++;}
\DoxyCodeLine{165 }
\DoxyCodeLine{166     xSemaphoreGive(mutexForInsertRemove);}
\DoxyCodeLine{167 \}}
\DoxyCodeLine{168 }
\DoxyCodeLine{169 \textcolor{comment}{/*}}
\DoxyCodeLine{170 \textcolor{comment}{typedef bool(*IntTypeCompare)(int, int);}}
\DoxyCodeLine{171 \textcolor{comment}{}}
\DoxyCodeLine{172 \textcolor{comment}{static IntTypeCompare kk = [](int x, int y) \{x = y; \};}}
\DoxyCodeLine{173 \textcolor{comment}{*/}}

\end{DoxyCode}
