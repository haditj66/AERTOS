//generated file: C:/AERTOS/AERTOS/src/AE/AECoreTests\testSPB.cpp
//**********************************************************************
//this is an auto-generated file using the template file located in the directory of C:\CodeGenerator\CodeGenerator\bin\Debug\..\..\FileTemplates\Files
//ONLY WRITE CODE IN THE UserCode_Section BLOCKS
//If you write code anywhere else,  it will be overwritten. modify the actual template file if needing to modify code outside usersection blocks.

//############################################### 
//this is an autogenerated file using cgen's macro2 command. Dont modify this file here unless it is in user sections 
//###############################################


 
#if INTEGRATION_TESTS_FOR_AECoreTests__testSPB
 
#include "IntegTestPipeline.h"


#include "AECore.h"
#include "AE_Init.h" 
#include "AEClock.h" 
#include "AEObjects.h" 

DECLARE_ALL_AO_PTR

static void clock1_callback(TimerHandle_t xTimerHandle);
static uint32_t sensor1_data[1];
static uint32_t sensor2_data[1];
static uint32_t sensor3_data[1];




//UserCode_Sectiona
//UserCode_Sectiona_end

void RunSelectedIntegrationTest_testSPB()
{

AE_Init();
 //UserCode_Sectionbeforemain
	
#ifdef BOARD_USED__STM32F411RE
	GPIO_InitTypeDef gpiotim; 
	gpiotim.Pin = GPIO_PIN_1;
	gpiotim.Mode = GPIO_MODE_OUTPUT_PP;
	gpiotim.Pull = GPIO_NOPULL;
	gpiotim.Speed = GPIO_SPEED_HIGH;
	HAL_GPIO_Init(GPIOA, &gpiotim);
#endif
	
	AEITEST_END_TestsAfterTimer_AECoreTests(5000);
	AEITEST_EXPECT_TEST_TO_RUN_AECoreTests("average");
	
//UserCode_Sectionbeforemain_end

static AEClock<AEObservorSensor, AEObservorInterpretorBaseDUMMY, 3, 0, 0, 0, 0, 0,0, 0, 0,0, 0, 0,0, 0, 0,0, 0, 0,0, 0, 0> clock1L(1000, clock1_callback);
clock1 = &clock1L;

static AEObservorSensorFilterOut<> sensor1L((uint32_t*) sensor1_data, SensorResolution::Resolution12Bit  );
sensor1 = &sensor1L;

static AEObservorSensorFilterOut<> sensor2L((uint32_t*) sensor2_data, SensorResolution::Resolution12Bit  );
sensor2 = &sensor2L;

static AEObservorSensorFilterOut<> sensor3L((uint32_t*) sensor3_data, SensorResolution::Resolution12Bit  );
sensor3 = &sensor3L;

static AverageSPB< false,  10> averageSPB1L; averageSPB1L.InitSPBObserver(StyleOfSPB::EachSPBTask); 
averageSPB1 = &averageSPB1L;

static AverageSPB< false,  10> averageSPB2L; averageSPB2L.InitSPBObserver(StyleOfSPB::EachSPBTask); 
averageSPB2 = &averageSPB2L;

static AverageSPB< false,  10> averageSPB3L; averageSPB3L.InitSPBObserver(StyleOfSPB::EachSPBTask); 
averageSPB3 = &averageSPB3L;



//UserCode_Sectionbeforelinks
//UserCode_Sectionbeforelinks_end
static float averageSPB1chBuffer1[10];
averageSPB1->AddSignalFlowLinkToChannelWithCopy1(sensor1, averageSPB1chBuffer1, 0);
static float averageSPB2chBuffer1[10];
averageSPB2->AddSignalFlowLinkToChannelWithCopy1(sensor2, averageSPB2chBuffer1, 0);
static float averageSPB3chBuffer1[10];
averageSPB3->AddSignalFlowLinkToChannelWithCopy1(sensor3, averageSPB3chBuffer1, 0);


//UserCode_Sectionbeforeclock
//UserCode_Sectionbeforeclock_end
clock1->SetObservorToClock(sensor1, AEClock_PrescalerEnum::PRESCALER1);
clock1->SetObservorToClock(sensor2, AEClock_PrescalerEnum::PRESCALER1);
clock1->SetObservorToClock(sensor3, AEClock_PrescalerEnum::PRESCALER1);


//AEITEST_END_TestsAfterTimer_AECoreTests(5000);
//UserCode_Sectionb
//UserCode_Sectionb_end

AEAO::ConfigureAndStart();
}


//UserCode_Sectionc
//UserCode_Sectionc_end


static void clock1_callback(TimerHandle_t xTimerHandle) {  
  //UserCode_Sectionclock1before
	
	sensor1_data[0] = sensor1_data[0] > 9 ? 1 : (sensor1_data[0] + 1);
	sensor2_data[0] = sensor2_data[0] > 9 ? 1 : (sensor2_data[0] + 1);
	sensor3_data[0] = sensor3_data[0] > 9 ? 1 : (sensor3_data[0] + 1);
	
	if (sensor1_data[0] == 10)
	{  
		//char* bb = new char[2800];
		//char* bb2 = new char[2800];
		//memset(bb, 2, 2800);
//		AEStartTimer(1) 
#ifdef BOARD_USED__STM32F411RE
	    //HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_1); 
#endif
		//memcpy(bb,bb2,2800); //this gives 700 us which gave only 400 us on the other AERTOS with IAR with no optimization.
		//HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_1); 
		
	}
//UserCode_Sectionclock1before_end 
  
 clock1->Tick(); 
  //UserCode_Sectionclock1after
	if (sensor1_data[0] % 2 == 0)
	{
		 
#ifdef BOARD_USED__STM32F411RE
		//HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_1); 
#endif
		AEStopTimer(2)
		float timel = AEGetTimerDuration(2);
		float timel3 = 23; 
		AELogTimer(2, "clockspeedcorrect");
		
		static volatile float time2 = AEGetTimerDuration(2);
		
#ifdef OS_USED__NONE
		AEITEST_AECoreTests("clockfreq", time2 > 800000 && time2 < 1200000, "frequency of AEclock should be about 1 millisec"); 
#else
		//using a OS will make this frequency x2 for some reason.
		AEITEST_AECoreTestEXE("clockfreq", time2 > 500000 && time2 < 2400000, "frequency of AEclock should be about 1 millisec"); 
#endif
	}
	else
	{ 
#ifdef BOARD_USED__STM32F411RE
//		HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_1); 
#endif
		AEStartTimer(2)

	}
//UserCode_Sectionclock1after_end 
}


#endif